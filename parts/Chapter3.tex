\section{Исследование и построение решения задачи}
\label{sec:Chapter3} \index{Chapter3}

% Требуется разбить большую задачу, описанную в постановке, на более мелкие
% подзадачи. Процесс декомпозиции следует продолжать до тех пор, пока подзадачи
% не станут достаточно простыми для решения непосредственно. Это может быть
% достигнуто, например, путем проведения эксперимента, доказательства теоремы
% или поиска готового решения.

Самые распространённые гонки, встречающиеся в реальных проектах, можно разделить на три категории. Ниже они рассмотрены по отдельности.

\subsection{Гонка на содержимом файла}

\lstset{language=bash,caption={Пример Makefile с гонкой на содержимом файла race\_file}}
\begin{lstlisting}[language=bash]
all: write_first_part write_second_part
write_first_part:
	echo 'a' > file.out
write_second_part:
	echo 'b' >> file.out
\end{lstlisting}

В этом примере цели \texttt{write\_first\_part} и \texttt{write\_second\_part} записывают текст в один и тот же файл. Между этими целями нет зависимостей, соответственно, они могут быть исполнены в любом порядке. При многопоточной сборке содержимое результирующего файла \texttt{file.out} будет неопределённым (либо \texttt{"ab"}, либо \texttt{"a"}).

Аналогичная проблема может произойти, если цели \texttt{write\_a} и \texttt{write\_b} будут использовать жёсткие ссылки на файл \texttt{file.out}. Тогда несмотря на то, что при сборке записи будут произведены по разным путям, они всё равно образуют состояние гонки на содержимом файла. Из этого следует, что при поиске таких гонок важно учитывать не пути к файлам, а идентификатор содержимого файла. В качестве такого идентификатора предлагается использовать номер inode.

\subsection{Гонка на пути к файлу}

Этот класс гонок отличается тем, что для его поиска необходимо использовать пути к файлам, а не номера inode.

\lstset{language=bash,caption={Пример Makefile с гонкой на пути}}
\begin{lstlisting}
all: file copy_1 copy_2
file:
	echo 'a' > file
copy_1: file
	cp file file\_copy
	# Something is done with file_copy
	rm file_copy
copy_2: file
	cp file file_copy
	# Something else is done with file_copy
	rm file_copy
\end{lstlisting}

В этом примере между целями \texttt{copy\_1} и \texttt{copy\_2} нет зависимости, однако они создают и удаляют файл по одному и тому же пути. Если бы сборка этих целей была запущена параллельно, то мог бы возникнуть конфликт.

При пересоздании файла его номер inode может измениться. В этом примере при сборке целей \texttt{copy\_1} и \texttt{copy\_2} файл \texttt{file\_copy} имеет различные номера inode, поэтому обнаружить гонку, полагаясь только на эту информацию, невозможно. Для обнаружения гонок с участием удаления необходимо полагаться именно на пути к файлам.

\subsection{Гонка между созданием директории и файла внутри неё}

\lstset{language=bash,caption={Пример Makefile с гонкой третьей категории}}
\begin{lstlisting}
all: build build/file.out

build:
    mkdir -p build

build/a.out:
    echo "a" > build/a.out

\end{lstlisting}
