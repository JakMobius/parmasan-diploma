\section{Исследование и построение решения задачи}
\label{sec:Chapter3} \index{Chapter3}

% Требуется разбить большую задачу, описанную в постановке, на более мелкие
% подзадачи. Процесс декомпозиции следует продолжать до тех пор, пока подзадачи
% не станут достаточно простыми для решения непосредственно. Это может быть
% достигнуто, например, путем проведения эксперимента, доказательства теоремы
% или поиска готового решения.

Самые распространённые гонки, встречающиеся в реальных проектах, можно разделить на три категории. Далее, по ходу их рассмотрения, будут предложены алгоритмы для их автоматического обнаружения.

\subsection{Гонка на содержимом файла}

\lstinputlisting[
	caption={Пример Makefile с гонкой на содержимом файла file.out},
    language=bash,
    label=lst:race-condition-1,
    escapechar=\%,
    morekeywords={all, write_a, append_b}
]{src/file-content-race-1.make}

В этом примере цели \texttt{write\_a} и \texttt{write\_b} записывают текст в один и тот же файл. Между этими целями нет зависимостей, соответственно, они могут быть исполнены в любом порядке. При многопоточной сборке содержимое результирующего файла \texttt{file.out} будет неопределённым (либо \texttt{"ab"}, либо \texttt{"a"}).

Основная идея автоматического обнаружения гонок заключается в отслеживании операций с файлами и сопоставление их с графом зависимостей системы сборки. Самый простой способ увидеть, как процесс работает с файлами - это запустить его под утилитой strace.

\lstinputlisting[
	caption={Вывод утилиты strace при сборке Makefile из листинга \ref{lst:race-condition-1}},
]{src/strace-log.txt}

В полученном логе можно видеть, как процесcы 1060 и 1061 открывают file.out с помощью системного вызова \texttt{openat}. Однако этой информации мало: неизвестно, какие цели сборки скрываются за этими номерами.

Чтобы сопоставить номера процессов с целями сборки предлагается модифицировать саму утилиту Make. В качестве подопытного был взят проект remake. Он реализует тот же функционал, что и GNU Make, но требует значительно меньше усилий для сборки из исходного кода. После внесения изменений (см. приложение \ref{subsec:remake-patch}) в логе появилась недостающая информация:

\lstinputlisting[
	caption={Лог сборки Makefile из листинга \ref{lst:race-condition-1} с модифицированным remake},
    language=bash,
    morekeywords={all, write_a, append_b}
]{src/strace-log-with-make-patch.txt}

Обработав полученный лог примитивным скриптом, можно установить, что процессы 1060 и 1061, которым соответствуют цели \texttt{write\_a} и \texttt{append\_b}, производят запись по одному и тому же пути - file.out. Из этого следует, что воизбежание гонок указанные цели должны выполняться в одном и том же порядке. Иными словами - между ними должна быть зависимость.

\begin{figure}[H]
	\caption{Граф зависимостей Makefile из листинга \ref{lst:race-condition-1}}
	\centering
	\begin{tikzpicture}[every node/.style = draw]
        \node[inner xsep=7pt] (append) at (0,0) {append\_b};
        \node[inner xsep=7pt] (write) at (0,1.2) {write\_a};
        \node[inner xsep=7pt] (all) at (3,0.6) {all};


        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, <->] (append) -- (write);
        \draw[red, line width=1pt, -] (-0.2,0.5) -- (0.2,0.7);
        \draw[red, line width=1pt, -] (0.2,0.5) -- (-0.2,0.7);

        \graph {
            (write) ->[line width=1pt, shorten >=2pt, shorten <=2pt] (all);
            (append) ->[line width=1pt, shorten >=2pt, shorten <=2pt] (all);
        };
    \end{tikzpicture}
\end{figure}

Легко убедиться в том, что схема сборки из примера не содержит такой зависимости: между целями \texttt{write\_a} и \texttt{append\_b} нет ориентированного пути, соответственно гонка имеет место. Таким образом, шаг за шагом, был построен алгоритм автоматического поиска состояний гонок первой категории:

\begin{enumerate}
	\item Произвести сборку с использованием strace и модифицированного remake;
	\item Получить соответствие между pid и целями сборки;
	\item Получить список доступов к файлам для каждой известной цели;
	\item Найти конфликтующие доступы к одному и тому же пути из разных целей;
	\item Убедиться в том, что в графе зависимостей существуют зависимости между целями, производящими конфликтующие доступы;
\end{enumerate}

В таком виде у алгоритма есть одно ограничение. Если цели \texttt{write\_a} и \texttt{append\_b} будут использовать жёсткие ссылки на файл \texttt{file.out} (например, \texttt{file.out.link1} и \texttt{file.out.link2}), состояние гонки будет по-прежнему присутствовать, но в логе доступов будут фигурировать пути от разных жёстких ссылок. Поскольку алгоритм полагается на совпадение путей, эта гонка не будет выявлена. Чтобы это исправить, нужно использовать некоторый <<уникальный идентификатор>> файла, который позволит прозрачно сравнивать между собой жесткие ссылки.

В Linux в качестве такого идентификатора можно использовать номер index node (inode). Узнать его можно через системный вызов \texttt{stat}, обратившись к полю \texttt{st\_ino}. Согласно стандарту ядра, жесткие ссылки внутри одной файловой системы ссылаются на одну и ту же inode \cite{inode-docs}. Если речь идёт о нескольких файловых системах, то потребуется обратить внимание ещё и на device number (поле \texttt{st\_dev} из той же структуры \texttt{stat}). В разработанном инструменте это учтено, однако далее в этой работе device number будет опускаться для простоты.

\subsection{Гонка на пути к файлу}

Этот класс гонок отличается тем, что для его поиска необходимо использовать пути к файлам, а не номера inode.

\lstinputlisting[
	caption={Пример Makefile с гонкой на пути},
	language=bash,
	morekeywords={all, something, something_else, rm}
]{src/file-path-race-3.make}

В этом примере между целями \texttt{something} и \texttt{something\_else} нет зависимости, однако они создают и удаляют файл по одному и тому же пути. Если бы сборка этих целей была запущена параллельно, то мог бы возникнуть конфликт.

При пересоздании файла его номер inode может измениться. В этом примере при сборке целей \texttt{something} и \texttt{something} файл \texttt{tmp\_file} имеет различные номера inode, поэтому обнаружить гонку, полагаясь только на эту информацию, невозможно. Для обнаружения гонок с участием удаления необходимо полагаться именно на пути к файлам.

\subsection{Гонка между созданием директории и файла внутри неё}

\lstinputlisting[
	caption={Пример Makefile с гонкой третьей категории}
    language=bash,
    morekeywords={all, mkdir}
]{src/directory-race-4.make}
