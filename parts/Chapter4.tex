\section{Описание практической части}
\label{sec:Chapter4} \index{Chapter4}

% Если в рамках работы писался какой-то код, здесь должно быть его
% описание: выбранный язык и библиотеки и мотивы выбора, архитектура,
% схема функционирования, теоретическая сложность алгоритма, характеристики
% функционирования (скорость/память).

Согласно разработанной архитектуре, трассировщик и санитайзер разделены на два отдельных процесса. Используя Unix-сокеты, санитайзер получает от трассировщика информацию о доступах к файлам и о порождении новых процессов, а от remake --- дерево зависимостей и соответствие целей сборки номерам процессов (pid).

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
        \node[style=draw, rounded corners, inner xsep=10pt, inner ysep=6pt] (parmasan) at (-1, 0) {Санитайзер};
        \node[style=draw, rounded corners, inner xsep=10pt, inner ysep=6pt] (tracer) at (3.2, 0) {Трассировщик};
        \node[style=draw, rounded corners, inner xsep=10pt, inner ysep=6pt] (make) at (7, 0) {remake};
        \node[minimum width=2cm, minimum height=0.7cm, gray, style=draw, rounded corners] (child1) at (11, 1) {gcc};
        \node[minimum width=2cm, minimum height=0.7cm, gray, style=draw, rounded corners] (child2) at (11, 0) {mkdir};
        \node[minimum width=2cm, minimum height=0.7cm, gray, style=draw, rounded corners] (child3) at (11, -1) {...};

        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (parmasan) -- (tracer);
        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (tracer) -- (make);
        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (make) to[in=180, out=0] (child1);
        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (make) to[in=180, out=0] (child2);
        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (make) to[in=180, out=0] (child3);

        \draw[gray, dashed, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (child1.south west) to[in=310, out=205] (tracer);
        \draw[gray, dashed, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (child2.south west) to[in=310, out=190] (tracer);
        \draw[gray, dashed, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (child3.south west) to[in=310, out=175] (tracer);
        \draw[gray, dashed, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (make) to[in=310, out=230] (tracer);

        \draw[line width=1pt, dashed, shorten >=2pt, shorten <=2pt, ->] (tracer) to[out=240, in=300] (parmasan);
        \draw[line width=1pt, dashed, shorten >=2pt, shorten <=2pt, ->] (make) to[out=150, in=30] (parmasan);

        \node[gray, font=\small] (text1) at (6.7, -2) {События ptrace};
        \node[gray, font=\small] (text1) at (1, -2) {События над файлами и процессами};
        \node[gray, font=\small] (text2) at (3.5, 1.8) {Соответствие процессов целям и граф зависимостей};
    \end{tikzpicture}

    \caption{Схема межпроцессного взаимодействия при сборке под санитайзером}
    \label{fig:parmasan-processes}
\end{figure}

На рис. \ref{fig:parmasan-processes} сплошные стрелки связывают родительские процессы с дочерними, пунктирные стрелки указывают передачу данных через Unix-сокеты, и пунктирные серые стрелки показывают, как трассировщик перехватывает системные вызовы, производимые процессами правее, используя системный вызов \texttt{ptrace}.

Выбор такой архитектуры позволяет изолировать санитайзер от непосредственной работы с файловой системой и с дочерними процессами. Результат работы санитайзера определяется лишь сообщениями, которые он получает от трассировщика и от процессов remake. Позже это решение также позволит значительно ускорить итеративную отладку гонок.

Поскольку трассировщик является сравнительно тонкой обёрткой над системным вызовом \texttt{ptrace}, он был написан на языке Си. Для санитайзера, как для более сложного проекта, был выбран язык C++.

\subsection{Построение дерева процессов}

Информация о процессах приходит санитайзеру из двух источников. Первым трассировщик сообщает о создании нового процесса путём отслеживания системных вызовов \texttt{clone}, \texttt{spawn} и \texttt{fork}. Если процесс был порождён процессом remake, он должен передать информацию о цели, которой этот процесс соответствует. Это позволит санитайзеру соотнести операции над файлами с целями сборки (см. \ref{subsec:link-ops-with-targets}).

По умолчанию трассировщик останавливает все порождаемые процессы на первой инструкции. Это необходимо для того, чтобы успеть настроить перехват системных вызовов и передать санитайзеру информацию о созданном процессе раньше, чем тот начнёт совершать какие-либо действия. Когда санитайзер получает сообщение о создании нового процесса, он добавляет его в общее дерево и отправляет подтверждение трассировщику. Дождавшись ответа, трассировщик позволяет самому процессу начать работу.

Если процесс успеет открыть какой-то файл раньше, чем санитайзер узнает его цель, он не сможет отнести этот доступ к правильной цели, и может упустить гонку. Поэтому цель, которой соответствует процесс, должна быть получена санитайзером раньше, чем этот процесс будет запущен. Это позволяет сделать схема \texttt{fork}/\texttt{exec}. После вызова \texttt{fork} pid процесса становится известен. В этот момент remake отправляет его вместе с названием цели санитайзеру. Дождавшись ответного сообщения, и убедившись что санитайзер установил соответствие между процессом и целью, remake заканчивает создание нового процесса вызовом \texttt{exec}.

Утилита remake поддерживает несколько способов порождения новых процессов. Кроме классического \texttt{fork/exec} поддерживается и более эффективный метод, использующий \texttt{posix\_spawn}. Этот способ, однако, не позволяет узнать pid нового процесса перед его запуском. Его нужно отключить, указав флаг \texttt{--disable-posix-spawn} в фазе configure.

\subsection{Обработка вложенных Make}

Крупные проекты бывают разделены на несколько схем сборки, каждая из которых отвечает за свой модуль. <<Корневой>> Makefile запускает их сборку, вызывая вложенный Make. Таким образом, проект можно представить как дерево из модулей. Гонки могут происходить между разными модулями одного проекта.

Для корректной обработки таких случаев санитайзер производит отдельный поиск гонок для каждого Make-процесса с использованием его схемы сборки. При поиске учитываются только те доступы к файлам, которые производились ниже по дереву процессов. Вложенные Make игнорируются, а доступам сопоставляются только цели из схемы текущего Make-процесса.

\subsection{Режим интерактивной отладки}

\subsection{Протокол взаимодействия}
\label{subsec:pstree}

Архитектура инструмента предполагает обмен данными между процессами посредством сокета. Ниже представлен пример сообщения, которым трассировщик сообщает санитайзеру, что определённый процесс открыл файл в режиме чтения.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% symbol width = 10.2 / 47 = 0.217
        \node at (0, 0) {\texttt{ASYNC READ 16 /lib64/libc.so.6 1005 15 646356 7}};

        % ASYNC:
		% -5.1 + 0.217 * 0 = -5.1
        % -5.1 + 0.217 * 5 = -4.015
        \draw[line width=0.7pt] (-5.1, -0.25) -- (-4.0375, -0.25);
        \draw[line width=0.7pt] (-5.1, -0.25) -- (-5.1, -4.5);
        \node[align=flush left, font=\footnotesize, minimum width=4cm, text width=4cm] at (-3.2, -5.1) {Флаг синхронности сообщения.};


        % READ:
        % -5.1 + 0.217 * 6 = -3.798
        % -5.1 + 0.217 * 10 = -2.93
        \draw[line width=0.7pt] (-3.798, -0.25) -- (-2.93, -0.25);
        \draw[line width=0.7pt] (-3.798, -0.25) -- (-3.798, -3);
        \node[align=flush left, font=\footnotesize, minimum width=5cm, text width=5cm] at (-1.398, -3.8) {Название события. В данном случае --- \texttt{READ} --- чтение файла.};

        % 16:
        % -5.1 + 0.217 * 11 = -2.713
        % -5.1 + 0.217 * 13 = -2.279
        \draw[line width=0.7pt] (-2.713, -0.25) -- (-2.279, -0.25);
        \draw[line width=0.7pt] (-2.713, -0.25) -- (-2.713, -2);
        \node[align=flush left, font=\footnotesize, minimum width=4cm, text width=4cm] at (-0.813, -2.6) {Длина строки, следующей далее.};

        % /lib64/libc.so.6:
        % -5.1 + 0.217 * 14 = -2.062
        % -5.1 + 0.217 * 30 = 1.41
        \draw[line width=0.7pt] (-2.062, -0.25) -- (1.41, -0.25);
        \draw[line width=0.7pt] (-2.062, -0.25) -- (-2.062, -0.5);
        \node[align=flush left, font=\footnotesize, minimum width=3cm, text width=3cm] at (-0.662, -1.3) {Путь, по которому процесс обратился к файлу.};

        % 1005:
        % -5.1 + 0.217 * 31 = 1.627
        % -5.1 + 0.217 * 35 = 2.495
        \draw[line width=0.7pt] (1.627, -0.25) -- (2.495, -0.25);
        \draw[line width=0.7pt] (1.627, -0.25) -- (1.627, -4);
        \node[align=flush left, font=\footnotesize, minimum width=6cm, text width=6cm] at (4.527, -4.6) {pid процесса, производящего доступ к файлу.};

        % 15:
        % -5.1 + 0.217 * 36 = 2.712
        % -5.1 + 0.217 * 38 = 3.146
        \draw[line width=0.7pt] (2.712, -0.25) -- (3.146, -0.25);
        \draw[line width=0.7pt] (2.712, -0.25) -- (2.712, -3);
        \node[align=flush left, font=\footnotesize, minimum width=4cm, text width=4cm] at (4.612, -3.6) {Device number файловой системы.};

        % 646356:
        % -5.1 + 0.217 * 39 = 3.363
        % -5.1 + 0.217 * 45 = 4.665
        \draw[line width=0.7pt] (3.363, -0.25) -- (4.665, -0.25);
       	\draw[line width=0.7pt] (3.363, -0.25) -- (3.363, -2);
       	\node[align=flush left, font=\footnotesize, minimum width=4cm, text width=4cm] at (5.263, -2.6) {Номер inode прочитанного файла.};

        % 7:
        % -5.1 + 0.217 * 46 = 4.882
        % -5.1 + 0.217 * 47 = 5.099
        \draw[line width=0.7pt] (4.882, -0.25) -- (5.099, -0.25);
        \draw[line width=0.7pt] (4.882, -0.25) -- (4.882, -0.5);
        \node[align=flush left, font=\footnotesize, minimum width=3cm, text width=3cm] at (6.282, -1.3) {Код возврата системного вызова \texttt{open}.};
    \end{tikzpicture}

    \caption{Пример сообщения, передаваемого санитайзеру трассировщиком}
\end{figure}

Любое сообщение, отправляемое санитайзеру, должно начинаться с флага синхронности (слова \texttt{SYNC} или \texttt{ASYNC}). Он указывает, ожидает ли отправляющая сторона ответное сообщение, как подтверждение того что событие было обработано. В пункте \ref{subsec:pstree} был приведён пример некоторых типов сообщений, требующих подобной синхронизации.

Следующее слово определяет тип передаваемого события. Каждый тип имеет свой набор аргументов. Если аргументом является строка (например, путь к файлу), то перед её началом передаётся её длина и один разделяющий символ пробела. Такой подход был выбран вместо экранирования для максимального упрощения построения и разбора сообщений. Протокол позволяет использовать для этого стандартные функции \texttt{sscanf} и \texttt{sprintf}.

Перечень сообщений, отправляемых трассировщиком санитайзеру:

\begin{enumerate}
	\item \texttt{INIT TRACER} --- инициализирующее сообщение.
	\item \texttt{CHILD <pid> <ppid> <cmdline>} --- Сообщает о создании нового процесса в дереве, или о том, что существующий процесс сменил свою \texttt{cmdline}, вызвав \texttt{exec}. Это сообщение всегда является синхронным, см. \ref{subsec:pstree}.
	\item \texttt{READ <}Путь к файлу\texttt{> <pid> <devnum> <inum> <}код возврата\texttt{>} --- событие открытия процессом файла на чтение.
	\item \texttt{WRITE <}Путь к файлу\texttt{> <pid> <devnum> <inum> <}код возврата\texttt{>}
	--- событие открытия процессом файла на запись.
	\item \texttt{UNLINK <}Путь к файлу\texttt{> <pid> <devnum> <inum> <}код возврата\texttt{>} --- событие удаления пути (directory entry)
	\item \texttt{INODE\_UNLINK <}Путь к файлу\texttt{> <pid> <devnum> <inum> <}код возврата\texttt{>} --- дублирует сообщение \texttt{UNLINK} в случае, если удалённый путь был последней жесткой ссылкой на свою inode.
	\item \texttt{DIE <pid>} --- синхронное сообщение. Сообщает о завершении работы процесса с указанным pid. Если свою работу завершает сам трассировщик, он отправляет это сообщение с собственным pid. В этом случае сообщение должно быть синхронным. Это будет гарантировать, что санитайзер успеет обработать все предыдущие сообщения от трассировщика прежде, чем получит сигнал \texttt{SIGCHLD} и остановится.
\end{enumerate}

Перечень сообщений, отправляемых процессом remake санитайзеру:

\begin{enumerate}
	\item \texttt{INIT MAKE} --- инициализирующее сообщение.
	\item \texttt{TARGET\_PID <pid> <ppid> <cmdline>} --- Устанавливает соответствие между процессом с указанным pid и целью, породившей его. Это сообщение всегда является синхронным, см. \ref{subsec:pstree}.
	\item \texttt{DEPENDENCY <target\_a> <target\_b>} --- Сообщает о наличии зависимости между двумя целями. Это сообщение должно являться синхронным, поскольку санитайзер должен получить весь граф зависимостей, прежде чем сможет находить потенциальные гонки между получаемыми им доступами.
\end{enumerate}

В обратную сторону санитайзер может отправить только слово \texttt{ACK} (от англ. --- Acknowledged, принято). Оно отправляется как подтверждение завершения обработки предыдущего сообщения, если это требуется флагом синхронности.

Трассировщик и remake не передают собственные pid по сокету. Ядро Linux позволяет санитайзеру получить эти данные проще, используя системный вызов \texttt{getsockopt} и флаг \texttt{SO_PEERCRED} \cite{seqpacket}.

В качестве режима для сокета был выбран \texttt{SOCK\_SEQPACKET}. Он гарантирует порядок доставки и сохранение границ сообщений. \cite{seqpacket}.

Имена событий подобраны таким образом, чтобы их можно было отличать лишь по первому символу. (Сообщение \texttt{INIT} является исключением, но его отличает то, что оно всегда идёт первым). Это позволяет использовать \texttt{switch} для вызова нужного отладчика. Несмотря на то, что передаваемые сообщения являются человекочитаемыми, а не бинарными, простота протокола позволяет избежать значительных потерь в производительности.

\subsection{Режим интерактивной отладки}

При отладке состояний гонок разработчикам часто требуется многократно пересобирать проект, устанавливая отладочные выводы на сборке определённых целей. В разработанном инструменте предусмотрен режим интерактивной отладки. Он позволяет экономить время одновременно двумя способами:

\begin{enumerate}
	\item Поскольку санитайзер опирается только на получаемые им сообщения, выполнять поиск гонок можно отложенно: если перенаправить все входящие сообщения в файл, и уже после передать их на вход санитайзера, то результат его работы будет таким же, как и если бы сборка происходила прямо сейчас. Такое <<воспроизведение>> записи занимает значительно меньше времени, чем обычная пересборка проекта.
	\item Интерактивный режим позволяет устанавливать точки останова при обнаружении гонки или на определённых действиях с файлами. Разработчику не требуется искать и открывать нужный Makefile и искать цели, работающие с этими файлами.
\end{enumerate}

Для реализации точек останова в санитайзер был добавлен режим отладки. При его активации, все передаваемые по сокету сообщения становятся синхронными. При срабатывании точки останова на определённом доступе к файлу санитайзер перестаёт отправлять \texttt{ACK}-сообщения. Трассировщик не позволит процессу продолжить работу, пока не получит ответное сообщение, и сборка остановится.

При срабатывании точки останова санитайзер предоставляет пользователю интерактивную консоль, с помощью которой можно вывести информацию о текущем состоянии сборки, а именно:

\begin{itemize}
	\item Цель, при сборке которой произошел этот доступ;
	\item Процесс, непосредственно производящий этот доступ;
	\item Информацию по любому процессу, даже завершённому:
	\begin{itemize}
		\item Командную строку процесса;
		\item Список целей его Makefile, если он является Make-процессом;
		\item Цепочку его родительских процессов;
		\item Поддерево процессов, порожденных им.
	\end{itemize}
\end{itemize}

Точка останова может быть привязана к произвольному множеству путей, задаваемым одним или нескольскими glob-выражениями. Используя алгоритмы, преподаваемые в рамках курса <<Формальные языки>>, санитайзер конвертирует их в МПДКА, поэтому сложность проверки не растёт с увеличением количества точек останова. Санитайзер может добавить уже к существующему МПДКА автомат с новой точкой останова, и привести сумму к новому МПДКА. Это позволяет добавлять и удалять точки останова в любой момент отладки без ухудшения производительности.

\subsection{Тестирование}