\section{Исследование и построение решения задачи}
\label{sec:Chapter3} \index{Chapter3}

% Требуется разбить большую задачу, описанную в постановке, на более мелкие
% подзадачи. Процесс декомпозиции следует продолжать до тех пор, пока подзадачи
% не станут достаточно простыми для решения непосредственно. Это может быть
% достигнуто, например, путем проведения эксперимента, доказательства теоремы
% или поиска готового решения.

Самые распространённые гонки, встречающиеся в реальных проектах, можно разделить на три категории. Далее, по ходу их рассмотрения, будут предложены алгоритмы для их автоматического обнаружения. Представленная классификация не является полной, однако, как будет показано в пункте~\ref{subsec:testing}, она покрывает большую часть известных гонок.

\subsection{Гонка на содержимом файла}
\label{subsec:file-content-races}

\lstinputlisting[
	caption={Пример Makefile с гонкой на содержимом объектных файлов},
    language=bash,
    label=lst:race-condition-1,
    escapechar=\%,
    morekeywords={all, write_a, append_b}
]{src/file-content-race-1.make}

В этом примере между целями \texttt{compile} и \texttt{link} не хватает зависимости. Аналогично примеру из введения, при многопоточной сборке цель \texttt{link} может попытаться скомпоновать объектные файлы, которых ещё не существует, или использовать старый, ещё не обновленный объектный файл.

Основная идея автоматического обнаружения гонок заключается в отслеживании операций с файлами и сопоставление их с графом зависимостей системы сборки. Можно увидеть, какие файлы открывают процессы, если запустить сборку под утилитой strace.

\lstinputlisting[
	caption={Фрагмент лога strace при сборке Makefile из листинга~\ref{lst:race-condition-1}},
]{src/strace-log.txt}

Во фрагменте полученного лога можно видеть, как процессы 1017, 1020 и 1025 открывают одни и те же объектные файлы с помощью системного вызова \texttt{openat}, причём первые два~--- на запись, а последний~--- на чтение. Однако этой информации мало: из лога нельзя понять, какие цели сборки скрываются за этими номерами.

\subsubsection{Сопоставление операций над файлами с целями сборки}
\label{subsubsec:link-ops-with-targets}

В этой работе вместо GNU Make будет использована её вариация~--- remake. В ней реализованы те же функции, что и GNU Make, но она требует значительно меньше усилий для сборки из исходного кода.

Получить информацию о том, какие процессы порождаются Make и каким целям они соответствуют, невозможно без модификации самой утилиты Make. В приложении~\ref{subsec:remake-patch} представлен патч, с помощью которого эту информацию можно вывести в консоль.

\lstinputlisting[
    label=lst:log-detailed,
	caption={Фрагмент лога сборки Makefile из листинга~\ref{lst:race-condition-1} с модифицированным remake},
    language=bash,
    morekeywords={all, write_a, append_b}
]{src/strace-log-with-make-patch.txt}

Можно заметить, что ни один процесс \texttt{gcc}, который запускается Make, не работает с файлами проекта напрямую. \texttt{gcc}~--- не компилятор, а драйвер, который запускает нужные компиляторы и компоновщики. Создание \texttt{main.o} и \texttt{lib.o} ведётся дочерними процессами \texttt{gcc}. В нашем случае это процессы \texttt{as}, порождённые системным вызовом \texttt{vfork}. Они генерируют объектные файлы на основе ассемблера, в который компилируется Си с помощью \texttt{cc1}~--- другого дочернего процесса \texttt{gcc}.

\begin{figure}[H]
	\centering
    \input{tikzpictures/fig:pstree1}
    \caption{Дерево процессов при сборке Makefile из листинга~\ref{lst:race-condition-1}}
    \label{fig:pstree1}
\end{figure}

Схему выше (кроме названий процессов) можно построить на данных из листинга~\ref{lst:log-detailed}. В ней, как и во фрагменте лога, опущены процессы \texttt{cc1}, поскольку они не производят доступов к интересующим нас объектным файлам.

Рассмотрим процессы 1020 и 1025. Согласно рис.~\ref{fig:pstree1}, им соответствуют цели \texttt{compile} и \texttt{link}. Из фрагмента лога в листинге~\ref{lst:log-detailed} можно установить, что процесс 1020 производит запись в файл \texttt{lib.o}, а процесс 1025~--- чтение того же файла. Запись и чтение нельзя менять местами, поскольку результат чтения может поменяться. Следовательно, процессы 1020 и 1025 должны запускаться строго друг за другом. Иными словами, между соответствующими целями~--- \texttt{compile} и \texttt{link}~--- должна быть зависимость. Проверим это, обратившись к графу зависимостей схемы.

\begin{figure}[H]
	\centering
	\input{tikzpictures/fig:dependency-graph.tex}
    \caption{Граф зависимостей Makefile из листинга~\ref{lst:race-condition-1}}
    \label{fig:dependency-graph}
\end{figure}

Легко убедиться в том, что схема сборки из примера не содержит такой зависимости: между целями \texttt{link} и \texttt{compile} нет ориентированного пути. Соответственно, в схеме сборки присутствует гонка. Теперь можно составить первый вариант алгоритма автоматического поиска состояний подобных гонок:

\begin{enumerate}
	\item Произвести сборку с использованием strace и модифицированного remake;
	\item Получить соответствие между pid и целями сборки;
	\item Получить список доступов к файлам для каждой известной цели;
	\item Найти конфликтующие доступы к одному и тому же пути из разных целей;
	\item Убедиться в том, что в схеме сборки существуют зависимости между целями, производящими конфликтующие доступы.
\end{enumerate}

В силу простоты примера конфликтующие доступы было найти достаточно легко. Однако, в общем случае выявление конфликтующих доступов~--- не такая тривиальная задача. Более подробно она будет рассмотрена в пункте~\ref{subsec:cricital-accesses}.

\subsubsection{Мотивация использования номеров inode}
\label{subsubsec:why-inodes}

В таком виде у алгоритма есть одно ограничение. Если цели \texttt{compile} и \texttt{link} будут использовать жёсткие ссылки на объектные файлы (например, \texttt{main.o.0} и \texttt{main.o.1}), гонка останется, но в логе доступов будут фигурировать пути от разных жёстких ссылок. Алгоритм выше не обнаружит такую гонку, поскольку полагается на совпадение путей как строк. Вместо этого нужно использовать какой-то другой способ сравнения, который бы учитывал жёсткие ссылки.

Согласно стандарту POSIX \cite{8277153}, каждый файл или директория имеет связанный с ним серийный номер, уникально идентифицирующий его в файловой системе. Его можно узнать из поля \texttt{st\_ino} структуры \texttt{stat}. Иногда этот номер называют номером index node, или, сокращённо, inode. Чтобы уникально идентифицировать файл во всей системе, нужно использовать его в паре с \texttt{st\_dev} --- идентификатором файловой системы (device number). В разработанном инструменте это учтено, однако для простоты далее в этой работе device number будет опускаться.

Номера inode могут быть использованы системой повторно, когда все жёсткие ссылки на файл оказываются удалены. Это может привести к тому, что разные файлы будут отражены в логе одними и теми же номерами inode, в результате чего алгоритм выдаст ложные срабатывания. Если добавить в лог события освобождения inode, скрипт для поиска гонок сможет отличать их поколения, и не выдавать ложных срабатываний при повторном использовании номера inode.

Прежде наш алгоритм полагался на разбор вывода strace. К сожалению, эта утилита не позволяет производить такие сложные проверки. Для этой цели лучше подходит \texttt{ptrace}~--- системный вызов для трассировки процессов, на основе которого реализован отладчик GDB, а так же сам strace. \texttt{ptrace} позволяет перехватывать управление процессом перед любыми системными вызовами, которые он совершает. Собственный трассировщик на основе \texttt{ptrace} позволит производить более сложные проверки и составлять более информативные логи, чем \texttt{strace}.

Перехватив управление процессом перед удалением файла или директории (системные вызовы \texttt{unlink(at)} или \texttt{rmdir}), трассировщик может проверить, что оно приведёт к освобождению номера inode. Linux указывает количество жёстких ссылок на файл в поле \texttt{st\_nlink} структуры \texttt{stat}. Перед удалением последней жёсткой ссылки (и, соответственно, перед освобождением номера inode) \texttt{st\_nlink} равняется 1 для файлов и 2 для директорий (каждая директория содержит <<\texttt{.}>>~--- жёсткую ссылку на себя). Произведя такую проверку, трассировщик сможет вывести в лог событие освобождения номера inode.

Таким образом, после всех исправлений, алгоритм приобретает следующий вид:

\begin{enumerate}
	\item Произвести сборку с использованием модифицированного remake и трассировщика на Си, использующего \texttt{ptrace};
	\item Получить соответствие между pid и целями сборки;
	\item Получить список доступов к inode для каждой известной цели;
	\item Найти конфликтующие доступы к одному и тому же поколению inode из разных целей;
	\item Убедиться в том, что в схеме сборки существуют зависимости между целями, производящими конфликтующие доступы к одному и тому же поколению inode.
\end{enumerate}

\subsection{Гонка на пути к файлу}
\label{subsec:path-race}

\lstinputlisting[
	caption={Пример Makefile с гонкой на пути к файлу},
    label=lst:race2,
	language=bash,
]{src/file-path-race-3.make}

В предыдущей главе был построен алгоритм для обнаружения состояния гонок на содержимом одного и того же файла. Здесь же речь пойдёт о разных файлах, которые были доступны по одному и тому же пути в разные моменты времени. В листинге~\ref{lst:race2} представлен распространённый сценарий гонки: независимые цели \texttt{something} и \texttt{something\_else} используют одно и то же имя для своих временных файлов. Если запустить сборку этих целей параллельно, то может возникнуть конфликт.

Значительная часть предыдущей главы была уделена корректной обработке жёстких ссылок, из-за которых файл может иметь несколько абсолютных путей. При работе с директориями в этом нет необходимости --- целью жёстких ссылок могут быть только файлы (за исключением <<.>> и <<..>>, которые не используются в абсолютных путях). Следовательно, для директорий корректно использовать их абсолютные пути в качестве уникального идентификатора. Стоит оговориться, что для этого нужно использовать разрешённый путь, то есть не содержащий переходов по символическим ссылкам. Далее под путями будут подразумеваться абсолютные разрешенные пути.

Пусть в директории по пути \textit{d} существует сущность (directory entry) с именем \textit{n}. Directory entry может быть каталогом или жёсткой ссылкой на inode (на файл). Поскольку путь к директории уникален, получить доступ к этой directory entry можно только через путь \textit{d\texttt{/}n}. Не может быть такого, что файл был удалён по пути \textit{d$_1$\texttt{/}n}, и перестал быть доступен по пути \textit{d$_2$\texttt{/}n}, где \textit{d}$_1$ $\ne$ \textit{d}$_2$. Таким образом, путь является уникальным идентификатором не только директорий, но и любой directory entry.

Поскольку гонка из примера связана с пересозданием directory entry по какому-либо пути, для её обнаружения достаточно проверять, что между целями, которые производят удаление (\texttt{unlink}) и повторное создание (\texttt{write}) этой directory entry, существует зависимость.

Операция удаления может образовать гонку не только с записью, но и с чтением, если оно произошло первым и использовало тот же путь, что и операция удаления. Такие гонки тоже можно отнести к этой категории. Никакие другие типы гонок не связаны с операцией удаления, поэтому разделение на категории останется корректным.

\subsection{Гонка между созданием директории и файла внутри неё}
\label{subsec:dir-race}

\lstinputlisting[
	caption={Пример Makefile с гонкой третьей категории},
	label=lst:race3,
    language=bash,
]{src/directory-race-4.make}

В листинге~\ref{lst:race3} цели \texttt{build} и \texttt{build/a.out} не зависят друг от друга. Если цель \texttt{build/a.out} начнёт собираться раньше, она не сможет создать файл в директории, которой ещё не существует. Такая гонка была обнаружена в проекте GPM с помощью \texttt{make -{}-shuffle}~\cite{race-3-example}.

Директория и файл внутри неё~--- разные элементы файловой системы, имеющие разные пути и разные номера inode, поэтому предыдущие алгоритмы не смогут обнаружить эту гонку. Простое решение~--- фиксировать доступ специального вида (directory lookup) к родительскому каталогу при любом обращении к находящемуся в нём файлу.

\begin{figure}[H]
    \centering
    \input{tikzpictures/fig:dirlookup-demo}
    \caption{Операции над файлами при сборке Makefile из листинга~\ref{lst:race3}}
    \label{fig:dirlookup-demo}
\end{figure}

Операция \texttt{dir\_lookup} позволила связать процесс \texttt{echo} из цели \texttt{build/a.out} с процессом \texttt{mkdir} из цели \texttt{build}. Поскольку теперь они производят чтение и запись на одной и той же директории, алгоритм поиска гонок из первой главы проверит наличие зависимости между их целями. Несмотря на то, что доступ \texttt{dir\_lookup} фиксируется только к ближайшему родительскому каталогу, этот принцип применим и для большего числа вложенных директорий.

\begin{figure}[H]
    \centering
    \input{tikzpictures/fig:dirlookup-demo-deep}
    \caption{Операции над файлами для большего числа вложенных директорий}
    \label{fig:dirlookup-demo-deep}
\end{figure}

При создании множественных вложенных директорий, доступ \texttt{dir\_lookup} связывает между собой все <<соседние>> процессы. Если окажется, что все процессы, которые создают цепочку вложенных директорий, связаны соответствующей цепочкой зависимостей, то гонки будут исключены. Верно и обратное: если, например, \texttt{mkdir build} и \texttt{mkdir build/foo} не связаны зависимостью (цепочка зависимостей разорвана), то присутствует гонка~--- вторая цель может исполниться раньше первой, что приведёт к ошибке.

\subsubsection{Обработка множественных попыток создания директории}

На практике представленный алгоритм часто выдаёт ложные срабатывания. Проблема в том, что хоть две записи в файл и являются критическими операциями (поскольку влияют на содержимое файла) и требуют наличия зависимости, две попытки создания одной и той же директории могут быть безопасно переставлены местами. Результат не поменяется~--- директория всё равно будет создана в тот же момент времени.

\lstinputlisting[
    caption={Пример Makefile с созданием директории build из нескольких целей},
    label=lst:race3-complex,
    language=bash,
]{src/directory-race-5.make}

В Makefile, изображённом на листинге~\ref{lst:race3-complex}, несколько целей самостоятельно создают каталог \texttt{build}, а затем используют его для сборки. На рис.~\ref{fig:false-mkdir-conflict} представлен сценарий сборки этого Makefile, при котором алгоритм выдаст ложные срабатывание.

\begin{figure}[H]
    \centering
    \input{tikzpictures/fig:false-mkdir-conflict}
    \caption{Возможный сценарий сборки Makefile из листинга~\ref{lst:race3-complex}}
    \label{fig:false-mkdir-conflict}
\end{figure}

Цель \texttt{lib1} выполнила \texttt{mkdir} первой. Когда \texttt{lib2} выполнила свой \texttt{mkdir}, он завершился ошибкой \texttt{EEXIST}, поскольку директория уже была создана. В связи с этим все дальнейшие \texttt{dir\_lookup} будут проверяться на зависимость с первым успешным \texttt{mkdir}, совершенным целью \texttt{lib1}. Это приведёт к ложным срабатываниям. В связи с этим, метод, описанный в предыдущих главах, не подходит для обнаружения гонок на каталоге.

Чтобы утверждать о отсутствии гонки, достаточно убедиться, что перед любой операцией \texttt{dir\_lookup} директория гарантированно будет создана. Для этого нужно проверить, что существует хотя бы одна операция \texttt{write} (вероятно, неуспешная), которая гарантированно произойдет раньше этого \texttt{dir\_lookup}. Чтобы реализовать такую проверку, нужно начать учитывать неуспешные \texttt{mkdir}, которые завершились с \texttt{EEXIST}, как на рис.~\ref{fig:false-mkdir-conflict-fixed}.

\begin{figure}[H]
    \centering
    \input{tikzpictures/fig:false-mkdir-conflict-fixed}
    \caption{Учитывание неуспешных \texttt{mkdir}}
    \label{fig:false-mkdir-conflict-fixed}
\end{figure}

В примере выше \texttt{dir\_lookup} можно связать с неуспешным \texttt{mkdir}, который был произведён раньше той же целью. Таким образом, ложное срабатывание будет исключено.

Необходимо также учесть случай, когда \texttt{dir\_lookup} происходит раньше любого \texttt{write}. Это означает, что директория была создана до начала сборки, и сообщать о гонке не нужно.

\subsection{Поиск конфликтующих доступов}
\label{subsec:cricital-accesses}

Базовый алгоритм поиска гонок, сформулированный в главе~\ref{subsec:file-content-races}, содержит пункт <<Найти конфликтующие доступы к одному и тому же пути (поколению inode) из разных целей>>. В этой части работы будет подробно рассмотрена задача поиска таких доступов.

Определим, какие виды доступов требуется поддерживать, чтобы обнаруживать все представленные ранее виды гонок.

\begin{itemize}
    \item \texttt{read(path, inode)}~--- Чтение файла на заданном пути с заданным номером inode
    \item \texttt{write(path, inode)}~--- Запись файла / создание директории на заданном пути с заданным номером inode.
    \item \texttt{unlink\_path(path)}~--- Удаление указанного пути из файловой системы
    \item \texttt{release\_inode(inode)}~--- Освобождение номера inode (см.~\ref{subsubsec:why-inodes})
    \item \texttt{dir\_lookup(path)}~--- Доступ к директории перед обращением к файлу в ней (см.~\ref{subsec:dir-race})
\end{itemize}

Рассмотрим гонки на содержимом файла (см.~\ref{subsec:file-content-races}). Для их поиска требуются только номера inode. Соответственно, актуальными для них могут являться только доступы \texttt{read}, \texttt{write} и \texttt{release\_inode}. Последний вид доступа~--- удаление всех жёстких ссылок на inode. Гонки, вовлекающие операцию удаления, относятся к следующей категории, поэтому в рамках этого пункта будут рассмотрены только операции \texttt{read} и \texttt{write}.

Для любых двух последовательных операций на одном и том же номере inode можно легко сказать, являются ли они конфликтующими. Например, для пары операций чтения это неверно: результат будет одним и тем же вне зависимости от порядка. Чтение и запись могут образовать конфликт, поскольку от порядка будет зависеть результат чтения. Рассуждая аналогично, можно построить таблицу:

\begin{table}[H]
    \centering
    \begin{tabular}{cccc}
        \toprule
        & \texttt{read} & \texttt{write} \\
        \midrule
        \texttt{read} & $-$ & $+$ \\
        \texttt{write} & $+$ & $+$ \\
        \bottomrule
    \end{tabular}
    \caption{Таблица конфликтов между операциями для гонок типа~\ref{subsec:file-content-races}}
    \label{tab:conflict-table}
\end{table}

Для работы с произвольным числом доступов рассуждения требуется обобщить. Один из простых способов~--- применить таблицу~\ref{tab:conflict-table} ко всем соседним доступам на один и тот же номер inode. Однако такое обобщение не является корректным. На рис.~\ref{fig:naive-conflict-break} представлен простой контрпример.

\begin{figure}[H]
    \centering
    \input{tikzpictures/fig:naive-conflict-break}
    \caption{Контрпример для наивного алгоритма}
    \label{fig:naive-conflict-break}
\end{figure}

Такой алгоритм сочтёт конфликтующими только первую запись и первое чтение, несмотря на то, что второе чтение тоже обязано произойти строго позже записи в файл. Следовательно, проверять только соседние доступы недостаточно.

Другой простой способ обобщить рассуждения для любого числа доступов~--- применять таблицу ко всем возможным парам доступов. Такое решение корректно сработает на примере выше, однако не будет являться оптимальным: проверка всех возможных пар доступов требует $O(n^2)$ операций.

\subsubsection{Улучшенный алгоритм перебора доступов}
\label{subsubsec:linear-time-proof}

Отношение зависимости целей ($\rightarrow$) является транзитивным. Если цели $A$, $B$ и $C$ такие, что $A \rightarrow B$ и $B \rightarrow C$, то верно, что $A \rightarrow C$. Это рассуждение позволяет свести квадратичный перебор к линейному.

На схеме~\ref{fig:all-conflicts} изображена некоторая последовательность доступов к файлу. Стрелками связаны те доступы, для которых в таблице~\ref{tab:conflict-table} указан конфликт:

\begin{figure}[H]
    \centering
    \input{tikzpictures/fig:all-conflicts}
    \caption{Последовательность доступов с указанными конфликтами}
    \label{fig:all-conflicts}
\end{figure}

Можно заметить, что не обязательно проверять на зависимость все операции, связанные стрелками. Например, поскольку проверяется пара доступов $(1, 4)$ и $(4, 5)$, проверять $(1, 5)$ необязательно~--- зависимость между ними будет следовать из зависимости первых двух. Если подобным образом удалить из все <<избыточные>> стрелки, то схема приобретёт следующий вид:

\begin{figure}[H]
    \centering
    \input{tikzpictures/fig:stripped-conflicts}
    \caption{Последовательность доступов с удалёнными избыточными конфликтами}
    \label{fig:stripped-conflicts}
\end{figure}

\subsubsection{Доказательство линейности числа проверок}

Утверждается, что после удаления всех избыточных проверок, их количество сократится с квадратичного до линейного. Обозначим проверяемые пары доступов как множество рёбер $P:\{(A_i, A_j), j>i\}$ на вершинах доступов $A$. По условию, $P$ не содержит избыточных рёбер, то есть $\forall i < j < k (A_i, A_j) \in P \wedge (A_j, A_k) \in P \implies (A_i, A_k) \notin P$. Иными словами, $P$ можно рассматривать как антитранзитивное отношение.

Выделим в $A$ максимальные цепочки последовательных неконфликтующих доступов. Будем обозначать их как $N^k = (N^k_1, N^k_2, \ldots, N^k_n)$. Элементы между цепочками $N^k$ объединим в цепочки $C^k = (C^k_1, C^k_2, \ldots, C^k_m)$. Таким образом, $A = \sqcup A^i$, где каждый $A^i$ является цепочкой либо конфликтующих ($C^k$), либо неконфликтующих ($N^k$) соседних доступов. Рассмотрим оба типа цепочек и оценим число рёбер в подграфах, образованных ими.

\begin{itemize}
    \item Подграф на вершинах $(C^k_1, C^k_2, \dots C^k_m)$ содержит только рёбра между соседними доступами $C^k_i$ и $C^k_{i+1}$. Любые другие рёбра будут избыточными. Общее число рёбер в этом подграфе составит $|C^k| - 1$.
    \item В цепочке $(N^k_1, N^k_2, \dots N^k_n)$ все соседние доступы являются неконфликтующими, а значит, все $N^k_i$ являются операциями чтения (согласно таблице~\ref{tab:conflict-table}). Следовательно, любые произвольные два элемента из этой последовательности будут неконфликтующими, и число рёбер в подграфе на этих вершинах будет равно нулю.
\end{itemize}

\begin{figure}[H]
    \centering
    \input{tikzpictures/fig:cn-chains}
    \caption{Рёбра $P$ на цепочках $C$ и $N$}
    \label{fig:cn-chains}
\end{figure}

По построению, две соседних цепочки $A^k$ и $A^{k+1}$ всегда будут иметь противоположные типы. Рассмотрим случай $(C^k, N^{k+1})$. Тогда, согласно таблице, последний $C^k_i$ конфликтует со всеми чтениями из $N^{k+1}$. Поскольку $C^k_i$ является последним конфликтующим доступом перед $N^{k+1}$, такое ребро не может быть избыточным, следовательно, оно лежит в $P$. С другой стороны, никакой другой $C^k_n$ нельзя связать ребром напрямую с каким-либо чтением из $N^{k+1}$. Такое ребро дублировало бы собой существующий путь: $C^k_n \rightarrow C^k_{n+1} \rightarrow \ldots \rightarrow C^k_i \rightarrow N^{k+1}_j$. Аналогично, в случае $(N^k, C^{k+1})$, первый доступ $C^{k+1}_j$ был бы связан ребром со всеми $N^k_i$.

\begin{figure}[H]
    \centering
    \input{tikzpictures/fig:cnc-edges}
    \caption{Рёбра $P$ на последовательности цепочек вида $(C, N, C)$}
    \label{fig:cnc-edges}
\end{figure}

Таким образом, между вершинами из соседних цепочек $(C^{k-1}, N^k)$ или $(N^k, C^{k+1})$ присутствует $|N^k|$ рёбер. Их наличие гарантирует существование пути между любым элементом из первой и любым элементом из второй цепочки. Поскольку это верно для всех соседних цепочек, а весь набор доступов $A$ состоит из цепочек чередующихся типов, то любые два доступа из любых двух разных цепочек будут связаны односторонним путём. Следовательно, любые другие рёбра между цепочками будут избыточными.

В общей сложности число рёбер в графе не превысит $2 \cdot \Sigma_{N^i} |N^i| + \Sigma_{C^i} |C^i| \leq 2 \cdot \Sigma_{A^i} |A^i| \leq 2 \cdot |A|$.

Более того, такое множество $P$ образует минимальный набор проверок, которые необходимо выполнить для поиска потенциальных гонок. Поскольку никакое ребро в $P$ не является избыточным, удаление любого одного ребра приведёт к тому что два доступа $A_i$ и $A_j$, которые были им соединены, больше не будут иметь ориентированного пути, и не будут проверены на зависимость, несмотря на то что они должны быть проверены согласно таблице~\ref{tab:conflict-table}.

\subsubsection{Введение метода критических доступов и его применение для гонок вида \ref{subsec:file-content-races}}

Помимо линейности числа доступов, в предыдущем пункте было также показано, какой вид будет иметь интересующее нас множество рёбер для проверки ($P$):

\begin{itemize}
    \item Все доступы внутри цепочек вида ($C$) связаны друг с другом линейно;
    \item Все доступы из цепочек вида ($N$) связаны слева и справа с ближайшими соседями из соседних цепочек;
\end{itemize}

Эти правила легко реализовать алгоритмически. Необходимо лишь знать, где проходят границы между цепочками. Будем называть доступ критическим, если он принадлежит цепочке вида $C$ и некритическим, если он принадлежит цепочке вида $N$. В предыдущем пункте было замечено, что в контексте поиска гонок вида~\ref{subsec:file-content-races}, если доступ является некритическим, то он является чтением. В обратную сторону это не всегда верно: если среди двух операций записи встретится одна операция чтения, она не образует цепочку вида $N$, поскольку будет зависеть от обоих своих соседей.

Однако этот крайний случай не мешает провести однозначное соответствие между видами доступов и критичностью. Даже если на месте одиночного чтения вставить $N$---цепочку длины 1, итоговое множество $P$ не изменится:

\begin{figure}[H]
    \centering
    \input{tikzpictures/fig:short-n-chain}
    \caption{Независимость множества $P$ от наличия $N$-цепочек длины 1}
    \label{fig:short-n-chain}
\end{figure}

Таким образом, если вместо таблицы конфликтов использовать разделение доступов на критические и некритические, то можно проверять лишь минимальный набор зависимостей, имеющий линейный от числа доступов размер. Этот алгоритм и будет применяться в дальнейшем.

\subsubsection{Применение метода критических доступов для гонок вида \ref{subsec:path-race}}

Прежде были рассмотрены только гонки на содержимом файла (см.~\ref{subsec:file-content-races}). Для них критическим был определен доступ \texttt{write}, а некритическим~--- \texttt{read}. Остальные виды доступов не рассматривались: \texttt{unlink\_path} и \texttt{dir\_lookup} не связаны с номерами inode, а \texttt{release\_inode} является искусственным доступом для поиска гонок на каталоге.

В отличие от предыдущего случая, поиск гонок на пути к файлу требует список операций на пути, а не на номере inode (см.~\ref{subsec:path-race}). Среди всего списка доступов (см.~\ref{subsec:cricital-accesses}), с путями работают \texttt{read}, \texttt{write} и \texttt{unlink}. Есть также доступ типа \texttt{dir\_lookup}, но он предназначен только для поиска гонок с созданием директорий (см.~\ref{subsec:dir-race}) и не будет рассмотрен здесь.

Осталось разделить выбранные типы доступов на критические и некритические. Обратимся к пункту~\ref{subsec:path-race} и составим таблицу конфликтов для этого типа гонок.

\begin{table}[htbp]
    \centering
    \begin{tabular}{cccc}
        \toprule
        & \texttt{read} & \texttt{write} & \texttt{unlink} \\
        \midrule
        \texttt{read} & $-$ & $-$ & $+$\\
        \texttt{write} & $-$ & $-$ & $+$\\
        \texttt{unlink} & ? & $+$ & ?\\
        \bottomrule
    \end{tabular}
    \caption{Таблица конфликтов между операциями для гонок вида~\ref{subsec:path-race}}
    \label{tab:conflict-table-path-race}
\end{table}

Поскольку после удаления пути может быть только повторное его создание, пары (\texttt{unlink}, \texttt{unlink}) и (\texttt{unlink}, \texttt{read}) помечены знаком вопроса.

Можно заметить, что операции \texttt{read} и \texttt{write} не конфликтуют ни в каком сочетании. Это значит, что их можно отнести к некритическим доступам. Операция \texttt{unlink}, напротив, конфликтует с любой другой операцией, и следовательно, является критической.

Правильный выбор конфликтующих доступов важен для корректного поиска гонок. Если бы все операции кроме чтения (\texttt{unlink} и \texttt{write}) были помечены критическими, как в предыдущем пункте, гонкой на пути могли бы считаться две операции записи. На практике это привело бы к нежелательному дублированию: такая гонка обнаружилась бы и как гонка вида~\ref{subsec:path-race} (на содержимом файла) и как гонка вида~\ref{subsec:file-content-races} (на пути к файлу).

\subsubsection{Алгоритм поиска гонок вида \ref{subsec:dir-race}}

Согласно пункту~\ref{subsec:dir-race}, для поиска гонок этой категории требуется особый набор проверок, связанных через логическое <<или>>. Метод критических доступов не подходит для этого.

С другой стороны, алгоритм был уже почти полностью описан ранее. Каждую операцию \texttt{dir\_lookup} нужно проверить на наличие зависимости хотя бы с одной предшествующей попыткой создания (операцией \texttt{write}, быть может, неуспешной), произошедшую после последнего \texttt{unlink}. Наивная реализация этого алгоритма будет предполагать квадратичный перебор, однако его можно сократить до линейного, если использовать ленивый алгоритм и кешировать те цели, из которых \texttt{dir\_lookup} не порождает гонку.
