\section{Обзор существующих решений}
\label{sec:Chapter2} \index{Chapter2}

% Здесь надо рассмотреть все существующие решения поставленной задачи, но не
% просто пересказать, в чем там дело, а оценить степень их соответствия тем
% ограничениям, которые были сформулированы в постановке задачи.

Современные системы сборки предпринимают меры для борьбы с гонками. Например, система Bazel собирает каждую цель в отдельной виртуальной файловой системе, в которой есть только файлы, собранные зависимостям этой цели сборки~\cite{bazel-sandbox}. Такое ограничение исключает возникновение гонок: с каждой виртуальной файловой системой одновременно может работать одна цель сборки, в определённом фиксированном порядке. Однако, подобные системы пока не заместили собой стандартные, более простые утилиты, такие как Make и Ninja. Последние по-прежнему широко используются в современных проектах как непосредственно, так и в виде бекэнда для других, более высокоуровневых систем.

Для сборок на основе Make в настоящее время существует единственное решение поставленной проблемы~--- флаг \texttt{-{}-shuffle}, добавленный в GNU Make 4.4 в 2022 году~\cite{trofi-make-shuffle}. Принцип его работы заключается в случайной перестановке порядка сборки независимых целей. Такой подход увеличивает вероятность того, что существующая гонка проявится и приведёт к сбою. Полученная ошибка может помочь разработчику найти и исправить гонку.

Это решение легко встраивается в существующие проекты посредством добавления флага \texttt{-{}-shuffle} в аргументы Make или в переменную окружения \texttt{GNUMAKEFLAGS}. Если окружение не позволяет указывать переменные окружения или параметры командной строки, можно применить патч для Make~\cite{make-shuffle-patch}, активирующий режим \texttt{-{}-shuffle} по умолчанию.

Однако, в основе режима Make \texttt{-{}-shuffle} лежит случайный алгоритм. Это значит, что разработчику, вероятно, придётся полностью пересобрать проект много раз, прежде чем гонка себя проявит. Кроме этого, этим решением нельзя обнаружить гонки, которые проявляются только при параллельном выполнении целей. Распространённая причина появления таких гонок заключается в том, что несколько независимых целей могут использовать временный файл по одному и тому же пути. Это может привести к ошибке или к повреждению данных, если эти цели будут собираться одновременно. Далее в этой работе такой вид гонок будет отнесён к классу <<Гонки на пути к файлу>>. Случайная перестановка сборки независимых целей в режиме \texttt{-{}-shuffle} не способствует проявлению таких гонок.