\section{Описание практической части}
\label{sec:Chapter4} \index{Chapter4}

% Если в рамках работы писался какой-то код, здесь должно быть его
% описание: выбранный язык и библиотеки и мотивы выбора, архитектура,
% схема функционирования, теоретическая сложность алгоритма, характеристики
% функционирования (скорость/память).

Согласно разработанной архитектуре, трассировщик и санитайзер представляют собой два отдельных процесса. Используя Unix-сокеты, санитайзер получает от трассировщика информацию о доступах к файлам и о порождении новых процессов, а от remake --- дерево зависимостей и соответствие целей сборки номерам процессов (pid).

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[style=draw, rounded corners, inner xsep=10pt, inner ysep=6pt] (parmasan) at (-1, 0) {Санитайзер};
        \node[style=draw, rounded corners, inner xsep=10pt, inner ysep=6pt] (tracer) at (3.2, 0) {Трассировщик};
        \node[style=draw, rounded corners, inner xsep=10pt, inner ysep=6pt] (make) at (7, 0) {remake};
        \node[minimum width=2cm, minimum height=0.7cm, gray, style=draw, rounded corners] (child1) at (11, 1) {gcc};
        \node[minimum width=2cm, minimum height=0.7cm, gray, style=draw, rounded corners] (child2) at (11, 0) {mkdir};
        \node[minimum width=2cm, minimum height=0.7cm, gray, style=draw, rounded corners] (child3) at (11, -1) {...};

        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (parmasan) -- (tracer);
        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (tracer) -- (make);
        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (make) to[in=180, out=0] (child1);
        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (make) to[in=180, out=0] (child2);
        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (make) to[in=180, out=0] (child3);

        \draw[gray, dashed, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (child1.south west) to[in=310, out=205] (tracer);
        \draw[gray, dashed, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (child2.south west) to[in=310, out=190] (tracer);
        \draw[gray, dashed, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (child3.south west) to[in=310, out=175] (tracer);
        \draw[gray, dashed, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (make) to[in=310, out=230] (tracer);

        \draw[line width=1pt, dashed, shorten >=2pt, shorten <=2pt, ->] (tracer) to[out=240, in=300] (parmasan);
        \draw[line width=1pt, dashed, shorten >=2pt, shorten <=2pt, ->] (make) to[out=150, in=30] (parmasan);

        \node[gray, font=\small] (text1) at (6.7, -2) {События ptrace};
        \node[gray, font=\small] (text1) at (1, -2) {События над файлами и процессами};
        \node[gray, font=\small] (text2) at (3.5, 1.8) {Соответствие процессов целям и граф зависимостей};
    \end{tikzpicture}

    \caption{Схема межпроцессного взаимодействия при сборке под санитайзером}
    \label{fig:parmasan-processes}
\end{figure}

На рис. \ref{fig:parmasan-processes} сплошные стрелки связывают родительские процессы с дочерними, пунктирные стрелки указывают передачу данных через Unix-сокеты, и пунктирные серые стрелки показывают, как трассировщик перехватывает системные вызовы, производимые процессами правее, используя системный вызов \texttt{ptrace}.

Выбранная архитектура позволяет изолировать санитайзер от непосредственной работы с файловой системой и с дочерними процессами. Результат работы санитайзера определяется лишь сообщениями, которые он получает от трассировщика и от процессов remake. Позже это решение также позволит значительно ускорить итеративную отладку гонок.

Дерево зависимостей передаётся санитайзеру из Make-процесса. Это позволяет избежать написания своего синтаксического анализатора для Makefile. В дополнение, такой подход гарантирует, что граф зависимостей, на основании которого производится поиск гонок, в точности соответствует настоящему графу зависимостей, который используется самой утилитой Make.

Поскольку трассировщик является сравнительно тонкой обёрткой над системным вызовом \texttt{ptrace}, он был написан на языке Си. Для санитайзера, как для более сложного проекта, был выбран язык C++.

\subsection{Построение дерева процессов}

Информация о процессах приходит санитайзеру из двух источников. Первым трассировщик сообщает о создании нового процесса путём отслеживания системных вызовов \texttt{clone}, \texttt{spawn} и \texttt{fork}. Если процесс был порождён процессом remake, он должен передать информацию о цели, которой этот процесс соответствует. Это позволит санитайзеру соотнести операции над файлами с целями сборки (см. \ref{subsec:link-ops-with-targets}).

По умолчанию трассировщик останавливает все новые процессы на первой инструкции. Это необходимо для того, чтобы успеть настроить перехват системных вызовов и передать санитайзеру информацию о созданном процессе раньше, чем тот начнёт совершать какие-либо действия. Когда санитайзер получает сообщение о создании нового процесса, он добавляет его в общее дерево и отправляет подтверждение трассировщику. Дождавшись ответа, трассировщик позволяет процессу начать работу.

Если процесс успеет открыть какой-то файл раньше, чем санитайзер узнает его цель, он не сможет отнести этот доступ к правильной цели, и может упустить гонку. Поэтому цель, которой соответствует процесс, должна быть получена санитайзером раньше, чем этот процесс будет запущен. Это позволяет реализовать схема \texttt{fork/exec}. После вызова \texttt{fork} pid процесса становится известен. В этот момент remake отправляет его вместе с названием цели санитайзеру. Дождавшись ответного сообщения, и убедившись что санитайзер установил соответствие между процессом и целью, remake заканчивает создание нового процесса вызовом \texttt{exec}.

Утилита remake поддерживает несколько способов порождения новых процессов. Кроме классического \texttt{fork/exec} поддерживается и более эффективный метод, использующий \texttt{posix\_spawn}. Этот способ, однако, не позволяет узнать pid нового процесса перед его запуском. Его нужно отключить, указав флаг \texttt{--disable-posix-spawn} в фазе configure.

\subsection{Обработка вложенных Make}

Крупные проекты бывают разделены на несколько схем сборки, каждая из которых отвечает за свой модуль. <<Корневой>> Makefile запускает их сборку, вызывая вложенный Make. Таким образом, проект можно представить как дерево из модулей. Гонки могут происходить между разными модулями одного проекта.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node (tracer) at (3.8, 0) {...};
        \node[style=draw, rounded corners, inner xsep=10pt, inner ysep=6pt] (make) at (7, 0) {remake};
        \node[minimum width=2cm, minimum height=0.7cm, gray, style=draw, rounded corners] (child1) at (11, 1) {gcc};
        \node[minimum width=2cm, minimum height=0.7cm, gray, style=draw, rounded corners] (child2) at (11, 0) {mkdir};
        \node[minimum width=2cm, minimum height=0.7cm, style=draw, rounded corners] (child3) at (11, -1) {remake};

        \node[minimum width=2cm, minimum height=0.7cm, gray, style=draw, rounded corners] (child31) at (15, 0) {ld};
        \node[minimum width=2cm, minimum height=0.7cm, gray, style=draw, rounded corners] (child32) at (15, -1) {rm};
        \node[minimum width=2cm, minimum height=0.7cm, gray, style=draw, rounded corners] (child33) at (15, -2) {...};

        \draw[gray, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (tracer) -- (make);
        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (make) to[in=180, out=0] (child1);
        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (make) to[in=180, out=0] (child2);
        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (make) to[in=180, out=0] (child3);

        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (child3) to[in=180, out=0] (child31);
        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (child3) to[in=180, out=0] (child32);
        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (child3) to[in=180, out=0] (child33);

        % \node[gray, font=\small] (text1) at (6.7, -2) {События ptrace};
        % \node[gray, font=\small] (text1) at (1, -2) {События над файлами и процессами};
        % \node[gray, font=\small] (text2) at (3.5, 1.8) {Соответствие процессов целям и граф зависимостей};
    \end{tikzpicture}

    \caption{Дерево процессов при исползовании вложенных Make}
    \label{fig:nested-make-pstree}
\end{figure}

Для корректной обработки таких случаев санитайзер производит поиск гонок в контексте каждого Make-процесса отдельно. При этом учитываются те цели и зависимости, которые определены в схеме сборки, обрабатываемой именно этим Make-процессом. Каждый <<контекст>> производит поиск гонок на основе доступов к файлам, производимым ниже по дереву процессов.

Рассмотрим процесс \texttt{ld} из рис. \ref{fig:nested-make-pstree}. Предположим, что он был порождён целью сборки \texttt{target2}, а вложенный Make, являющийся его родительским процессом, порождён целью \texttt{target1} во внешнем Make, как на рис. \ref{fig:nested-make-pstree-example}.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node (tracer) at (3.8, 0) {...};
        \node[style=draw, rounded corners, inner xsep=10pt, inner ysep=6pt] (make) at (7, 0) {remake};
        \node[minimum width=2cm, gray] (child1) at (11, 1.2) {...};
        \node[minimum width=2cm, minimum height=0.7cm, style=draw, rounded corners] (child2) at (11, 0) {remake};

        \node[minimum width=2cm, gray] (child21) at (15, 1.2) {...};
        \node[minimum width=2cm, minimum height=0.7cm, style=draw, rounded corners] (child22) at (15, 0) {ld};

        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (tracer) -- (make);
        \draw[gray, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (make) to[in=180, out=0] (child1);
        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (make) -- (child2) node[font=\footnotesize, midway, below] {target1};

        \draw[gray, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (child2) to[in=180, out=0] (child21);
        \draw[line width=1pt, shorten >=2pt, shorten <=2pt, ->] (child2) -- (child22) node[font=\footnotesize, midway, below] {target2};

        % \node[gray, font=\small] (text1) at (6.7, -2) {События ptrace};
        % \node[gray, font=\small] (text1) at (1, -2) {События над файлами и процессами};
        % \node[gray, font=\small] (text2) at (3.5, 1.8) {Соответствие процессов целям и граф зависимостей};
    \end{tikzpicture}

    \caption{Пример распространения событий при вложенных Make}
    \label{fig:nested-make-pstree-example}
\end{figure}

Если процесс \texttt{ld} на рис. \ref{fig:nested-make-pstree-example} произведёт чтение файла \texttt{libfoo.so}, то для вложенного Make этот доступ будет зарегистрирован как доступ к \texttt{libfoo.so} из цели \texttt{target2}, а для внешнего Make этот доступ будет зарегистрирован как доступ из цели \texttt{target1}.

Если бы система Linux позволяла устанавливать процессу множество отладчиков, то предложенный подход был бы эквивалентен запуску отдельной пары трассировщик-санитайзер для каждого вложенного Make. Это бы приравняло запуск вложенного Make к запуску обычного процесса. Все доступы к файлам, которые бы производились ниже, в контексте этого санитайзера присваивались бы к той цели, которая породила этот вложенный Make.

Альтернативное обоснование выбранного подхода следует из соображения о том, что любая цель, собираемая во вложенном Make, имеет зависимость от цели, которая породила сам вложенный Make-процесс. Честная проверка наличия зависимости между целью \texttt{A} из вложенного Make и целью \texttt{B} из внешнего Make сводилась бы к проверке наличия зависимости между целью, породившей вложенный Make и целью \texttt{B}.

\subsection{Протокол взаимодействия}
\label{subsec:pstree}

Архитектура инструмента предполагает обмен данными между процессами посредством сокета. Ниже представлен пример сообщения, которым трассировщик сообщает санитайзеру, что определённый процесс открыл файл в режиме чтения.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        % symbol width = 10.2 / 47 = 0.217
        \node at (0, 0) {\texttt{ASYNC READ 16 /lib64/libc.so.6 1005 15 646356 7}};

        % ASYNC:
        % -5.1 + 0.217 * 0 = -5.1
        % -5.1 + 0.217 * 5 = -4.015
        \draw[line width=0.7pt] (-5.1, -0.25) -- (-4.0375, -0.25);
        \draw[line width=0.7pt] (-5.1, -0.25) -- (-5.1, -4.5);
        \node[align=flush left, font=\footnotesize, minimum width=4cm, text width=4cm] at (-3.2, -5.1) {Флаг синхронности сообщения.};


        % READ:
        % -5.1 + 0.217 * 6 = -3.798
        % -5.1 + 0.217 * 10 = -2.93
        \draw[line width=0.7pt] (-3.798, -0.25) -- (-2.93, -0.25);
        \draw[line width=0.7pt] (-3.798, -0.25) -- (-3.798, -3);
        \node[align=flush left, font=\footnotesize, minimum width=5cm, text width=5cm] at (-1.398, -3.8) {Название события. В данном случае --- \texttt{READ} --- чтение файла.};

        % 16:
        % -5.1 + 0.217 * 11 = -2.713
        % -5.1 + 0.217 * 13 = -2.279
        \draw[line width=0.7pt] (-2.713, -0.25) -- (-2.279, -0.25);
        \draw[line width=0.7pt] (-2.713, -0.25) -- (-2.713, -2);
        \node[align=flush left, font=\footnotesize, minimum width=4cm, text width=4cm] at (-0.813, -2.6) {Длина строки, следующей далее.};

        % /lib64/libc.so.6:
        % -5.1 + 0.217 * 14 = -2.062
        % -5.1 + 0.217 * 30 = 1.41
        \draw[line width=0.7pt] (-2.062, -0.25) -- (1.41, -0.25);
        \draw[line width=0.7pt] (-2.062, -0.25) -- (-2.062, -0.5);
        \node[align=flush left, font=\footnotesize, minimum width=3cm, text width=3cm] at (-0.662, -1.3) {Путь, по которому процесс обратился к файлу.};

        % 1005:
        % -5.1 + 0.217 * 31 = 1.627
        % -5.1 + 0.217 * 35 = 2.495
        \draw[line width=0.7pt] (1.627, -0.25) -- (2.495, -0.25);
        \draw[line width=0.7pt] (1.627, -0.25) -- (1.627, -4);
        \node[align=flush left, font=\footnotesize, minimum width=6cm, text width=6cm] at (4.527, -4.6) {pid процесса, производящего доступ к файлу.};

        % 15:
        % -5.1 + 0.217 * 36 = 2.712
        % -5.1 + 0.217 * 38 = 3.146
        \draw[line width=0.7pt] (2.712, -0.25) -- (3.146, -0.25);
        \draw[line width=0.7pt] (2.712, -0.25) -- (2.712, -3);
        \node[align=flush left, font=\footnotesize, minimum width=4cm, text width=4cm] at (4.612, -3.6) {Device number файловой системы.};

        % 646356:
        % -5.1 + 0.217 * 39 = 3.363
        % -5.1 + 0.217 * 45 = 4.665
        \draw[line width=0.7pt] (3.363, -0.25) -- (4.665, -0.25);
        \draw[line width=0.7pt] (3.363, -0.25) -- (3.363, -2);
        \node[align=flush left, font=\footnotesize, minimum width=4cm, text width=4cm] at (5.263, -2.6) {Номер inode прочитанного файла.};

        % 7:
        % -5.1 + 0.217 * 46 = 4.882
        % -5.1 + 0.217 * 47 = 5.099
        \draw[line width=0.7pt] (4.882, -0.25) -- (5.099, -0.25);
        \draw[line width=0.7pt] (4.882, -0.25) -- (4.882, -0.5);
        \node[align=flush left, font=\footnotesize, minimum width=3cm, text width=3cm] at (6.282, -1.3) {Код возврата системного вызова \texttt{open}.};
    \end{tikzpicture}

    \caption{Пример сообщения, передаваемого санитайзеру трассировщиком}
\end{figure}

Любое сообщение, отправляемое санитайзеру, должно начинаться с флага синхронности (слова \texttt{SYNC} или \texttt{ASYNC}). Он указывает, ожидает ли отправляющая сторона ответное сообщение, как подтверждение того что событие было обработано. В пункте \ref{subsec:pstree} был приведён пример некоторых типов сообщений, требующих подобной синхронизации.

Следующее слово определяет тип передаваемого события. Каждый тип имеет свой набор аргументов. Если аргументом является строка (например, путь к файлу), то перед её началом передаётся её длина и один разделяющий символ пробела. Такой простой формат упрощает составление и разбор сообщений до нескольких вызовов \texttt{memcpy} и \texttt{sprintf} / \texttt{sscanf}.

Перечень сообщений, отправляемых трассировщиком санитайзеру:

\begin{enumerate}
    \item \texttt{INIT TRACER} --- инициализирующее сообщение.
    \item \texttt{CHILD <pid> <ppid> <cmdline>} --- Сообщает о создании нового процесса в дереве, или о том, что существующий процесс сменил свою \texttt{cmdline}, вызвав \texttt{exec}. Это сообщение всегда является синхронным, см. \ref{subsec:pstree}.
    \item \texttt{READ <}Путь к файлу\texttt{> <pid> <devnum> <inum> <}код возврата\texttt{>} --- событие открытия процессом файла на чтение.
    \item \texttt{WRITE <}Путь к файлу\texttt{> <pid> <devnum> <inum> <}код возврата\texttt{>}
    --- событие открытия процессом файла на запись.
    \item \texttt{UNLINK <}Путь к файлу\texttt{> <pid> <devnum> <inum> <}код возврата\texttt{>} --- событие удаления пути (directory entry)
    \item \texttt{INODE\_UNLINK <}Путь к файлу\texttt{> <pid> <devnum> <inum> <}код возврата\texttt{>} --- дублирует сообщение \texttt{UNLINK} в случае, если удалённый путь был последней жесткой ссылкой на свою inode.
    \item \texttt{DIE <pid>} --- сообщает о завершении работы процесса с указанным pid. Если свою работу завершает сам трассировщик, он отправляет это сообщение с собственным pid. В этом случае сообщение должно быть синхронным. Это будет гарантировать, что санитайзер успеет обработать все предыдущие сообщения от трассировщика прежде, чем получит сигнал \texttt{SIGCHLD} и остановится.
\end{enumerate}

Перечень сообщений, отправляемых процессом remake санитайзеру:

\begin{enumerate}
    \item \texttt{INIT MAKE} --- инициализирующее сообщение.
    \item \texttt{TARGET\_PID <pid> <ppid> <cmdline>} --- Устанавливает соответствие между процессом с указанным pid и целью, породившей его. Это сообщение всегда является синхронным, см. \ref{subsec:pstree}.
    \item \texttt{DEPENDENCY <target\_a> <target\_b>} --- Сообщает о наличии зависимости между двумя целями. Это сообщение должно являться синхронным, поскольку санитайзер должен получить весь граф зависимостей, прежде чем сможет находить потенциальные гонки между получаемыми им доступами.
\end{enumerate}

В обратную сторону санитайзер может отправить только слово \texttt{ACK} (от англ. --- Acknowledged, принято). Оно отправляется как подтверждение завершения обработки предыдущего сообщения, если это требуется флагом синхронности.

Санитайзер должен знать, какой pid имеет отправитель каждого сообщения. Ядро Linux позволяет получить эти данные, используя системный вызов \texttt{getsockopt} и флаг \texttt{SO\_PEERCRED} \cite{seqpacket}. Это избавляет от необходимости передавать эти данные по сокету.

В качестве режима для сокета был выбран \texttt{SOCK\_SEQPACKET}. Он гарантирует порядок доставки и сохранение границ сообщений. \cite{seqpacket}.

Имена событий подобраны таким образом, чтобы их можно было отличать лишь по первому символу (сообщение \texttt{INIT} является исключением, но его отличает то, что оно всегда идёт первым). Это позволяет использовать \texttt{switch} для вызова нужного отладчика. Несмотря на то, что передаваемые сообщения являются человекочитаемыми, а не бинарными, простота протокола позволяет избежать значительных потерь в производительности.

\subsection{Режим интерактивной отладки}

При отладке состояний гонок разработчикам часто требуется многократно пересобирать проект, устанавливая отладочные выводы на сборке определённых целей. В разработанном инструменте предусмотрен режим интерактивной отладки. Он позволяет экономить время одновременно двумя способами:

\begin{enumerate}
    \item Поскольку санитайзер опирается только на получаемые им сообщения, выполнять поиск гонок можно отложенно. Если перенаправить все входящие сообщения в файл, и уже после передать их на вход санитайзера, то результат его работы будет таким же, как и если бы сборка происходила прямо сейчас. Такое <<воспроизведение>> записи занимает значительно меньше времени, чем обычная пересборка проекта.

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \node[style=draw, rounded corners, inner xsep=10pt, inner ysep=6pt] (parmasan) at (5.0, -3) {Санитайзер в режиме чтения лога};
            \node[style=draw, rounded corners, inner xsep=10pt, inner ysep=6pt] (log) at (-1, -3) {Лог сборки};
            \node[style=draw, rounded corners, inner xsep=10pt, inner ysep=6pt] (logger) at (-1, 0) {Логгер};
            \node[style=draw, rounded corners, inner xsep=10pt, inner ysep=6pt] (tracer) at (3.2, 0) {Трассировщик};
            \node[style=draw, rounded corners, inner xsep=10pt, inner ysep=6pt] (make) at (7, 0) {remake};
            \node[minimum width=2cm, minimum height=0.7cm, gray, style=draw, rounded corners] (child1) at (11, 1) {gcc};
            \node[minimum width=2cm, minimum height=0.7cm, gray, style=draw, rounded corners] (child2) at (11, 0) {mkdir};
            \node[minimum width=2cm, minimum height=0.7cm, gray, style=draw, rounded corners] (child3) at (11, -1) {...};

            \draw[gray, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (logger) -- (tracer);
            \draw[gray, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (tracer) -- (make);
            \draw[gray, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (make) to[in=180, out=0] (child1);
            \draw[gray, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (make) to[in=180, out=0] (child2);
            \draw[gray, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (make) to[in=180, out=0] (child3);

            \draw[gray, dashed, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (child1.south west) to[in=310, out=205] (tracer);
            \draw[gray, dashed, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (child2.south west) to[in=310, out=190] (tracer);
            \draw[gray, dashed, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (child3.south west) to[in=310, out=175] (tracer);
            \draw[gray, dashed, line width=1pt, shorten >=2pt, shorten <=2pt, ->] (make) to[in=310, out=230] (tracer);

            \draw[line width=1pt, dashed, shorten >=2pt, shorten <=2pt, ->] (tracer) to[out=240, in=300] (logger);
            \draw[line width=1pt, dashed, shorten >=2pt, shorten <=2pt, ->] (make) to[out=150, in=30] (logger);
            \draw[line width=1pt, dashed, shorten >=2pt, shorten <=2pt, ->] (logger) -- (log);
            \draw[line width=1pt, dashed, shorten >=2pt, shorten <=2pt, ->] (log) -- (parmasan);

            % \node[gray, font=\small] (text1) at (6.7, -2) {События ptrace};
            % \node[gray, font=\small] (text1) at (1, -2) {События над файлами и процессами};
            % \node[gray, font=\small] (text2) at (3.5, 1.8) {Соответствие процессов целям и граф зависимостей};
        \end{tikzpicture}

        \caption{Запись и воспроизведение лога сборки}
        \label{fig:build-dumping}
    \end{figure}

    В случае, если санитайзер читает лог сборки, а не получает сообщения из сокета, использовать \texttt{SO\_PEERCRED} для получения pid отправителя невозможно. Эти данные указываются в логе явно, в начале каждого сообщения.

    \item Режим отладки позволяет устанавливать точки останова при обнаружении гонки или на определённых действиях с файлами. Разработчику не требуется искать и открывать нужный Makefile и искать цели, работающие с этими файлами.
\end{enumerate}

Для реализации точек останова в санитайзер был добавлен режим отладки. При его активации, все передаваемые по сокету сообщения становятся синхронными. При срабатывании точки останова на определённом доступе к файлу санитайзер перестаёт отправлять \texttt{ACK}-сообщения. Трассировщик не позволит процессу продолжить работу, пока не получит ответное сообщение, и сборка остановится.

При срабатывании точки останова санитайзер предоставляет пользователю интерактивную консоль, с помощью которой можно вывести информацию о текущем состоянии сборки, а именно:

\begin{itemize}
    \item Цель, при сборке которой произошел этот доступ;
    \item Процесс, непосредственно производящий этот доступ;
    \item Информацию по любому процессу, даже завершённому:
    \begin{itemize}
        \item Командную строку процесса;
        \item Список целей его Makefile, если он является Make-процессом;
        \item Цепочку его родительских процессов;
        \item Поддерево процессов, порожденных им.
    \end{itemize}
\end{itemize}

Точка останова может быть привязана к произвольному множеству путей, задаваемым одним или нескольскими glob-выражениями. Санитайзер конвертирует их в МПДКА, поэтому сложность проверки не растёт с увеличением количества точек останова. Санитайзер может добавить к существующему автомату новый, отвечающий за срабатывание на новой точке останова, с использованием логического <<ИЛИ>>. Затем сумму этих автоматов можно привести к новому МПДКА. Это позволяет добавлять и удалять точки останова в любой момент отладки без ухудшения производительности (удаление точки останова эквивалентно добавлению инвертированного автомата c логическим <<И>>).

\subsection{Тестирование и сравнение}

По мере разработки проекта был разработан набор из 23 автоматических тестов, проверяющих поведение санитайзера в известных крайних случаях. Среди них:

\begin{itemize}
    \item Обнаружение гонок, включающих:
    \begin{itemize}
        \item Обновление Makefile, влекущее перезапуск Make;
        \item Доступы, производящиеся самим Make-процессом.
        \item Создание вложенных директорий;
        \item Указание более чем одной цели для сборки Make-процессом;
        \item Использование шаблонных правил;
        \item Запуск вложенных Make.
    \end{itemize}
    \item Разрешение символических ссылок при доступе к файлу, но игнорирование их при удалении;
    \item Корректная нормализация пути (удаление \texttt{.} и \texttt{..});
\end{itemize}

Тестирование производится автоматически с использованием CI на LXC-контейнерах с тремя разными системами:

\begin{itemize}
    \item Ubuntu Mantic;
    \item OpenRC Gentoo 6.8.1;
    \item Alpine 3.19.
\end{itemize}

Сергей Трофимович, разработчик режима Make \texttt{--shuffle}, опубликовал в своём блоге список проектов, в которых ему удалось обнаружить гонки с использованием этого режима \cite{trofi-make-shuffle}. Оценка эффективности разработанного санитайзера производилась путём запуска его на проектах из этого же списка и сравнении полученных гонок с перечнем известных, обнаруженных ранее.

\begin{figure}[H]
    \centering
    \input{races.tex}
    \caption{Результаты тестирования инструмента на проектах с известными гонками}
    \label{fig:testing-results}
\end{figure}

Следует уточнить, что <<количество обнаруженных гонок>> не является формальной величиной. Санитайзер может обнаружить сотни и тысячи гонок, которые в действительности могут быть устранены одним исправлением в схеме сборки. В связи с этим, гонки, обнаруженные санитайзером, были сгруппированы вручную по схожести имён участвующих в них файлов и целей. Воизбежание завышения оценок, в спорных случаях гонки также группировались вместе, а ложные срабатывания, по возможности, не учитывались.

Например, гонка в проекте strace происходила из-за того, что шаблонное правило \texttt{mpers-m\%.stamp} не содержало зависимость с файлом \texttt{sys\_func.h} \cite{strace-race}. В таком случае санитайзер выведет отдельные сообщения о гонках для каждого файла, собираемого этим правилом. На рис. \ref{fig:testing-results} все такие гонки были сгруппированы вместе.

Диаграмма на рис. \ref{fig:testing-results} позволяет оценить эффективность разработанного инструмента. Среди 35 гонок, о которых сообщалось изначально, санитайзер успешно обнаружил 29, и сообщил о 10 новых.

\subsection{Пример новой обнаруженной гонки}

Рассмотрим одну из новых гонок, обнаруженных санитайзером в проекте Vim.

\lstinputlisting[
    caption={Диагностика санитайзера при сборке проекта Vim},
    language=bash,
    label=lst:vim-race,
]{src/vim-new-race-report.txt}

Диагностика, изображенная на листинге \ref{lst:vim-race}, сообщает о гонке на пути к файлу (\ref{subsec:file-content-races}). Как было замечено в пункте \ref{sec:Chapter2}, гонки этой категории нельзя обнаружить режимом \texttt{--shuffle}. Обратимся к рецептам целей, указанных в диагностике (\texttt{src/po/Makefile:216}).

\lstinputlisting[
    caption={Фрагмент схемы сборки Vim},
    language=bash,
    firstnumber=216]{src/vim-new-race.make}

Цели, указанные в диагностике, используют одно и то же имя (\texttt{LINGUAS}) для временного файла, что приводит к гонке на этом пути.

В версии 9.1.0108 эта гонка была исправлена путём добавления зависимости между целями \texttt{vim.desktop} и \texttt{gvim.desktop}. Для проведения справедливого сравнения санитайзер тестировался на версии 8.2.4595, которую использовал Сергей Трофимович при тестировании режима Make \texttt{--shuffle} и составлении публикации в своём блоге.

% TODO:
% - Сказать про то что надо хранить и PID и эпоху
% - Сказать про BPF
% - Измерить накладные расходы